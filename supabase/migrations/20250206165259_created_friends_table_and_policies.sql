alter type "public"."notification_types" rename to "notification_types__old_version_to_be_dropped";

create type "public"."notification_types" as enum ('new_friend', 'code_interaction');

create table "public"."friends" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null,
    "friend_id" uuid not null
);


alter table "public"."friends" enable row level security;

alter table "public"."notifications" alter column type type "public"."notification_types" using type::text::"public"."notification_types";

drop type "public"."notification_types__old_version_to_be_dropped";

alter table "public"."user_codes" alter column "referral_value" set not null;

CREATE UNIQUE INDEX friends_id_key ON public.friends USING btree (id);

CREATE UNIQUE INDEX friends_pkey ON public.friends USING btree (id);

CREATE UNIQUE INDEX unique_friendship ON public.friends USING btree (user_id, friend_id);

alter table "public"."friends" add constraint "friends_pkey" PRIMARY KEY using index "friends_pkey";

alter table "public"."friends" add constraint "friends_friend_id_fkey" FOREIGN KEY (friend_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."friends" validate constraint "friends_friend_id_fkey";

alter table "public"."friends" add constraint "friends_id_key" UNIQUE using index "friends_id_key";

alter table "public"."friends" add constraint "friends_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."friends" validate constraint "friends_user_id_fkey";

alter table "public"."friends" add constraint "unique_friendship" UNIQUE using index "unique_friendship";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_friend_request_notification()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN
  INSERT INTO public.notifications (type, recipient, triggered_by)
 VALUES ('new_friend', NEW.user_id, NEW.friend_id);
  
  RETURN NEW;
  END;$function$
;

CREATE OR REPLACE FUNCTION public.get_friends_with_codes(current_user_id uuid)
 RETURNS TABLE(created_at timestamp with time zone, profile jsonb, user_codes jsonb)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
    SELECT 
      friends.created_at,  -- Kept outside the profile object
      -- Wrap profile data inside a JSONB object
      jsonb_build_object(
        'id', profiles.id,  
        'avatar_url', profiles.avatar_url,
        'user_name', profiles.user_name
      ) AS profile,
      -- Aggregate user codes and associated company data into a JSONB array
      COALESCE(
        to_jsonb(
          array_agg(
            jsonb_build_object(
              'id', user_codes.id,  
              'referral_value', user_codes.referral_value,
              'company', jsonb_build_object(
                'id', companies.id,  
                'name', companies.name,
                'logo_url', companies.logo_url  
              )
            )
          )
        ), '[]'::jsonb
      ) AS user_codes  
    FROM 
      friends  -- Join with friends to get created_at
    JOIN 
      profiles ON friends.friend_id = profiles.id
    JOIN 
      user_codes ON user_codes.user_id = profiles.id
    JOIN 
      companies ON user_codes.company_id = companies.id
    WHERE 
      friends.user_id = current_user_id  
    GROUP BY 
      friends.created_at, profiles.id, profiles.avatar_url, profiles.user_name;  
END;
$function$
;

grant delete on table "public"."friends" to "anon";

grant insert on table "public"."friends" to "anon";

grant references on table "public"."friends" to "anon";

grant select on table "public"."friends" to "anon";

grant trigger on table "public"."friends" to "anon";

grant truncate on table "public"."friends" to "anon";

grant update on table "public"."friends" to "anon";

grant delete on table "public"."friends" to "authenticated";

grant insert on table "public"."friends" to "authenticated";

grant references on table "public"."friends" to "authenticated";

grant select on table "public"."friends" to "authenticated";

grant trigger on table "public"."friends" to "authenticated";

grant truncate on table "public"."friends" to "authenticated";

grant update on table "public"."friends" to "authenticated";

grant delete on table "public"."friends" to "service_role";

grant insert on table "public"."friends" to "service_role";

grant references on table "public"."friends" to "service_role";

grant select on table "public"."friends" to "service_role";

grant trigger on table "public"."friends" to "service_role";

grant truncate on table "public"."friends" to "service_role";

grant update on table "public"."friends" to "service_role";

create policy "Enable users to CRUD their own data only"
on "public"."friends"
as permissive
for all
to authenticated
using (((( SELECT auth.uid() AS uid) = user_id) OR (( SELECT auth.uid() AS uid) = friend_id)));


CREATE TRIGGER on_friend_added AFTER INSERT ON public.friends FOR EACH ROW EXECUTE FUNCTION create_friend_request_notification();


